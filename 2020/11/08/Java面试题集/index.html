<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Java面试题集 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.面向对象的特征有哪些方面？2.访问修饰符public,private,protected,以及不写（默认）时的区别？3.String 是最基本的数据类型吗？4.float f&#x3D;3.4;是否正确？5.short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗？6.try{}里有一个return语句，那么紧跟在这个try后的finally{}里的">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试题集">
<meta property="og:url" content="http://example.com/2020/11/08/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.面向对象的特征有哪些方面？2.访问修饰符public,private,protected,以及不写（默认）时的区别？3.String 是最基本的数据类型吗？4.float f&#x3D;3.4;是否正确？5.short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗？6.try{}里有一个return语句，那么紧跟在这个try后的finally{}里的">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-11-08T14:59:45.000Z">
<meta property="article:modified_time" content="2020-11-08T15:08:16.096Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java面试题集" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/08/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/" class="article-date">
  <time datetime="2020-11-08T14:59:45.000Z" itemprop="datePublished">2020-11-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java面试题集
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-面向对象的特征有哪些方面？"><a href="#1-面向对象的特征有哪些方面？" class="headerlink" title="1.面向对象的特征有哪些方面？"></a>1.面向对象的特征有哪些方面？</h2><h2 id="2-访问修饰符public-private-protected-以及不写（默认）时的区别？"><a href="#2-访问修饰符public-private-protected-以及不写（默认）时的区别？" class="headerlink" title="2.访问修饰符public,private,protected,以及不写（默认）时的区别？"></a>2.访问修饰符public,private,protected,以及不写（默认）时的区别？</h2><h2 id="3-String-是最基本的数据类型吗？"><a href="#3-String-是最基本的数据类型吗？" class="headerlink" title="3.String 是最基本的数据类型吗？"></a>3.String 是最基本的数据类型吗？</h2><h2 id="4-float-f-3-4-是否正确？"><a href="#4-float-f-3-4-是否正确？" class="headerlink" title="4.float f=3.4;是否正确？"></a>4.float f=3.4;是否正确？</h2><h2 id="5-short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？"><a href="#5-short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？" class="headerlink" title="5.short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？"></a>5.short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？</h2><h2 id="6-try-里有一个return语句，那么紧跟在这个try后的finally-里的代码会不会被执行，什么时候被执行，在return前还是后"><a href="#6-try-里有一个return语句，那么紧跟在这个try后的finally-里的代码会不会被执行，什么时候被执行，在return前还是后" class="headerlink" title="6.try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?"></a>6.try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?</h2><h2 id="7-列出一些你常见的运行时异常？"><a href="#7-列出一些你常见的运行时异常？" class="headerlink" title="7.列出一些你常见的运行时异常？"></a>7.列出一些你常见的运行时异常？</h2><h2 id="8-List、Set、Map是否继承自Collection接口？"><a href="#8-List、Set、Map是否继承自Collection接口？" class="headerlink" title="8.List、Set、Map是否继承自Collection接口？"></a>8.List、Set、Map是否继承自Collection接口？</h2><h2 id="9-List、Map、Set三个接口存取元素时，各有什么特点？"><a href="#9-List、Map、Set三个接口存取元素时，各有什么特点？" class="headerlink" title="9.List、Map、Set三个接口存取元素时，各有什么特点？"></a>9.List、Map、Set三个接口存取元素时，各有什么特点？</h2><h2 id="10-重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#10-重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="10.重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>10.重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h2><hr>
<h3 id="1-抽象、继承、封装、多态性"><a href="#1-抽象、继承、封装、多态性" class="headerlink" title="1.抽象、继承、封装、多态性"></a>1.抽象、继承、封装、多态性</h3><h3 id="抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。"><a href="#抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。" class="headerlink" title="抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。"></a>抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</h3><h3 id="继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。"><a href="#继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。" class="headerlink" title="继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。"></a>继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。</h3><h3 id="封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。"><a href="#封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。" class="headerlink" title="封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。"></a>封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。</h3><h3 id="多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1-方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2-对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。"><a href="#多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1-方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2-对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。" class="headerlink" title="多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。"></a>多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</h3><h3 id="2-———————————————"><a href="#2-———————————————" class="headerlink" title="2.———————————————"></a>2.———————————————</h3><h3 id="修饰符-当前类-同包-子类-其他包"><a href="#修饰符-当前类-同包-子类-其他包" class="headerlink" title="修饰符        当前类    同包    子类    其他包"></a>修饰符        当前类    同包    子类    其他包</h3><h3 id="public-√-√-√-√"><a href="#public-√-√-√-√" class="headerlink" title="public        √        √        √        √"></a>public        √        √        √        √</h3><h3 id="protected-√-√-√-×"><a href="#protected-√-√-√-×" class="headerlink" title="protected    √        √        √        ×"></a>protected    √        √        √        ×</h3><h3 id="default-√-√-×-×"><a href="#default-√-√-×-×" class="headerlink" title="default        √        √        ×        ×"></a>default        √        √        ×        ×</h3><h3 id="private-√-×-×-×"><a href="#private-√-×-×-×" class="headerlink" title="private        √        ×        ×        ×"></a>private        √        ×        ×        ×</h3><h3 id="———————————————–"><a href="#———————————————–" class="headerlink" title="———————————————–"></a>———————————————–</h3><h3 id="3-不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive-type），剩下的都是引用类型（reference-type），Java-5以后引入的枚举类型也算是一种比较特殊的引用类型。"><a href="#3-不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive-type），剩下的都是引用类型（reference-type），Java-5以后引入的枚举类型也算是一种比较特殊的引用类型。" class="headerlink" title="3.不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5以后引入的枚举类型也算是一种比较特殊的引用类型。"></a>3.不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5以后引入的枚举类型也算是一种比较特殊的引用类型。</h3><h3 id="4-不正确。3-4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float-f-float-3-4-或者写成float-f-3-4F-。"><a href="#4-不正确。3-4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float-f-float-3-4-或者写成float-f-3-4F-。" class="headerlink" title="4.不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。"></a>4.不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。</h3><h3 id="5-对于short-s1-1-s1-s1-1-由于1是int类型，因此s1-1运算结果也是int-型，需要强制转换类型才能赋值给short型。而short-s1-1-s1-1-可以正确编译，因为s1-1-相当于s1-short-s1-1-其中有隐含的强制类型转换。"><a href="#5-对于short-s1-1-s1-s1-1-由于1是int类型，因此s1-1运算结果也是int-型，需要强制转换类型才能赋值给short型。而short-s1-1-s1-1-可以正确编译，因为s1-1-相当于s1-short-s1-1-其中有隐含的强制类型转换。" class="headerlink" title="5.对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。"></a>5.对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。</h3><h3 id="6-会执行，在方法返回调用者前执行。"><a href="#6-会执行，在方法返回调用者前执行。" class="headerlink" title="6.会执行，在方法返回调用者前执行。"></a>6.会执行，在方法返回调用者前执行。</h3><h3 id="7-ArithmeticException（算术异常）"><a href="#7-ArithmeticException（算术异常）" class="headerlink" title="7.- ArithmeticException（算术异常）"></a>7.- ArithmeticException（算术异常）</h3><h3 id="ClassCastException-（类转换异常）"><a href="#ClassCastException-（类转换异常）" class="headerlink" title="- ClassCastException （类转换异常）"></a>- ClassCastException （类转换异常）</h3><h3 id="IllegalArgumentException-（非法参数异常）"><a href="#IllegalArgumentException-（非法参数异常）" class="headerlink" title="- IllegalArgumentException （非法参数异常）"></a>- IllegalArgumentException （非法参数异常）</h3><h3 id="IndexOutOfBoundsException-（下标越界异常）"><a href="#IndexOutOfBoundsException-（下标越界异常）" class="headerlink" title="- IndexOutOfBoundsException （下标越界异常）"></a>- IndexOutOfBoundsException （下标越界异常）</h3><h3 id="NullPointerException-（空指针异常）"><a href="#NullPointerException-（空指针异常）" class="headerlink" title="- NullPointerException （空指针异常）"></a>- NullPointerException （空指针异常）</h3><h3 id="SecurityException-（安全异常）"><a href="#SecurityException-（安全异常）" class="headerlink" title="- SecurityException （安全异常）"></a>- SecurityException （安全异常）</h3><h3 id="8-List、Set-是，Map-不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。"><a href="#8-List、Set-是，Map-不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。" class="headerlink" title="8.List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。"></a>8.List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。</h3><h3 id="9-List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals-方法来区分元素是否重复）。Map保存键值对（key-valuepair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O-1-，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。"><a href="#9-List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals-方法来区分元素是否重复）。Map保存键值对（key-valuepair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O-1-，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。" class="headerlink" title="9.List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-valuepair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。"></a>9.List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-valuepair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</h3><h3 id="10-方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。"><a href="#10-方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。" class="headerlink" title="10.方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。"></a>10.方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/08/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/" data-id="ckh995bxw00036ourdd8o5iq8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/11/05/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Java集合框架</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/08/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/">Java面试题集</a>
          </li>
        
          <li>
            <a href="/2020/11/05/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">Java集合框架</a>
          </li>
        
          <li>
            <a href="/2020/11/04/HTML%E6%A6%82%E5%BF%B5/">HTML概念</a>
          </li>
        
          <li>
            <a href="/2020/11/03/1103/">1103</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>